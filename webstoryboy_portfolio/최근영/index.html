<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <link rel="stylesheet" href="assets/css/reset.css">
    <link rel="stylesheet" href="assets/css/style.css">
</head>
<body>

    <div id="contents">
        <section id="section1">
            <canvas class="bg" id="webgl2"></canvas>
            <div class="center">
                <h1>portfolio
                    <span class="bg1"></span>
                </h1>
                <p>프론트를 위해 달리는 개발자 포트폴리오</p>
                <a href="#">고고</a>
            </div>
        </section>
    </div>


    <script src="https://unpkg.co/gsap@3/dist/gsap.min.js"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.3/examples/js/math/MeshSurfaceSampler.js"></script>
    
    <script>
        let scene = new THREE.Scene();
        
        let camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 17;
        let renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById("webgl"),
            antialias: true, 
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);

        let materials = [
            new THREE.MeshBasicMaterial({color:0x35DBFF, wireframe:true}),
            new THREE.MeshBasicMaterial({color:0xE4B7AF, wireframe:true}),
            new THREE.MeshBasicMaterial({color:0x30EB00, wireframe:true}),
            new THREE.MeshBasicMaterial({color:0xD54679, wireframe:true})
        ];
        let geometry = new THREE.IcosahedronGeometry(1, 1);
        
        for (let i = 0; i < 20; i ++) {
            const mesh = new THREE.Mesh(geometry, materials[Math.floor(Math.random() * 4)]);
            const scale = Math.random() + 0.5;
            mesh.scale.multiplyScalar(scale);
            mesh.position.random().subScalar(0.5).multiplyScalar(15);
            mesh.speed = new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.01);
            scene.add(mesh);
        }

        //애니메이션 설정
        function animate() {
            requestAnimationFrame(animate);

            scene.children.forEach(mesh => {
                mesh.rotation.x += mesh.speed.x;
                mesh.rotation.y += mesh.speed.y;
                mesh.rotation.z += mesh.speed.z;

                scene.rotation.x += 0.0001;
                scene.rotation.y += 0.0001;
                scene.rotation.z += 0.0001;
            });

            renderer.render(scene, camera);
        }
        animate();
  
        //화면 사이즈 설정
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize);
    </script> -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r122/three.min.js"></script>
    <script>
        var mouseX;
        var mouseY;

        //화면 생성
        const scene = new THREE.Scene();

        //카메라 설정
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 400;

        //렌더링 설정
        renderer = new THREE.WebGLRenderer({
            alpha:true,
            antialias:true, canvas: document.getElementById("webgl2")});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        
        //Geometry
        var distance = Math.min(200, window.innerWidth / 4);
        var geometry = new THREE.Geometry();

        for (var i = 0; i < 1600; i++) {
            var vertex = new THREE.Vector3();
            var theta = THREE.Math.randFloatSpread(360); 
            var theta = Math.acos(THREE.Math.randFloatSpread(2)); 
            var phi = THREE.Math.randFloatSpread(360); 

            vertex.x = distance * Math.sin(theta) * Math.cos(phi);
            vertex.y = distance * Math.sin(theta) * Math.sin(phi);
            vertex.z = distance * Math.cos(theta);

            geometry.vertices.push(vertex);
        }

        var particles = new THREE.Points(geometry, new THREE.PointsMaterial({color: 0xffffff, size: 1}));
        particles.boundingSphere = 50;

        var renderingParent = new THREE.Group();
        renderingParent.add(particles);

        var resizeContainer = new THREE.Group();
        resizeContainer.add(renderingParent);
        scene.add(resizeContainer);

        //조명 
        const lightAmbient = new THREE.AmbientLight(0x663399, 1)
        scene.add(lightAmbient)


        //애니메이션 설정
        function animate(a) {
            requestAnimationFrame(animate);

            renderer.render(scene, camera);
        }
        animate();

        //화면 사이즈 설정
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize);
        //document.addEventListener( 'mousemove', onMouseMove, false );

        //gsap
        var myTween;
        function onMouseMove(event) {
            if(myTween)
                myTween.kill();

                mouseX = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouseY = - ( event.clientY / window.innerHeight ) * 2 + 1;
                myTween = gsap.to(particles.rotation, {duration: 0.1, x: mouseY*-1, y: mouseX});
                particles.rotation.x = mouseY*-1;
                particles.rotation.y = mouseX;
            }
        animate();

        // Scaling animation
        var animProps = {scale: 1, xRot: 0, yRot: 0};
        gsap.to(animProps, {
            duration: 10, 
            scale: 2, 
            repeat: -1, 
            yoyo: true, 
            ease: "sine", 
            onUpdate: function() {
                renderingParent.scale.set(animProps.scale,animProps.scale,animProps.scale);
            }
        });

        gsap.to(animProps, {
            duration: 120, 
            xRot: Math.PI * 2, 
            yRot: Math.PI * 4, 
            repeat: -1, yoyo: true, 
            ease: "none", 
            onUpdate: function() {
                renderingParent.rotation.set(animProps.xRot,animProps.yRot,0);
            }
        });
    </script>
</body>
</html>