<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <link rel="stylesheet" href="http://gosu1234.dothome.co.kr/portfolio/font/stylesheet.css">
    <link rel="stylesheet" href="https://cherin0115.github.io/dothome21/portfolio/assets/css/fonts.css">
    <link rel="stylesheet" href="assets/css/reset.css">
    <link rel="stylesheet" href="assets/css/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Abel&display=swap" rel="stylesheet">

    <style>
        canvas {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 1;
            pointer-events: none;
        }

        .td-wrapper,
        canvas {
            transition: opacity 1s;
        }

        .td-wrapper:not(.td-hide)+canvas,
        .td-hide {
            opacity: 0;
        }
    </style>
</head>

<body>

    <header id="header">
        <span>frontand</span>
        <h1 class="title">The heri Times</h1>
        <span>Seoul korea</span>
    </header>
    <!-- header -->

    <main id="contents">
        <section id="section1">
            <div class="sec1">
                <div></div>
                <div>
                    <h2>FRONTEND</h2>
                    <p>
                        개발자로서, 저는 사이트 자체에 성격과 캐릭터를 부여하여 만드는 것을 좋아합니다. 사용자가 웹사이트에 들어왔을 때, 웹사이트의 특징을 빠르게 읽을 수 있고, 원하는 정보를
                        쉽게 가질수 있도록 해야할 것입니다. 그러기 위해서는 개발자로서 저는 특징을 빠르게 읽고, 그것을 시각적으로 또는 기능적으로 나타내줘야 한다고 생각합니다.
                        프론트엔드 개발자로는 아직 실무경험이 없지만, 하루하루 더 나아가기 위해서 배움의 자세로 성실히 공부하고 있습니다.
                    </p>
                </div>
                <div></div>
            </div>
        </section>
        <!-- //section1 -->

        <section id="section2">
            <div class="sec2">
                <div class="title" id="effectText">
                    <span>Developer</span>
                </div>
                <div class="about">
                    <div class="left">

                    </div>
                    <div class="right">
                        <div class="r1">
                            <div>FRONTEND</div>
                            <div>CREATIVE & </div>
                            <div>DEVELOP</div>
                            <p>
                                개발자로서, 저는 사이트 자체에 성격과 캐릭터를 부여하여 만드는 것을 좋아합니다. 사용자가 웹사이트에 들어왔을 때, 웹사이트의 특징을 빠르게 읽을 수 있고,
                                원하는 정보를 쉽게 가질수 있도록 해야할 것입니다. 그러기 위해서는 개발자로서 저는 특징을 빠르게 읽고, 그것을 시각적으로 또는 기능적으로 나타내줘야 한다고
                                생각합니다. 프론트엔드 개발자로는 아직 실무경험이 없지만, 하루하루 더 나아가기 위해서 배움의 자세로 성실히 공부하고 있습니다.
                                개발자로서, 저는 사이트 자체에 성격과 캐릭터를 부여하여 만드는 것을 좋아합니다. 사용자가 웹사이트에 들어왔을 때, 웹사이트의 특징을 빠르게 읽을 수 있고,
                                원하는 정보를 쉽게 가질수 있도록 해야할 것입니다. 그러기 위해서는 개발자로서 저는 특징을 빠르게 읽고, 그것을 시각적으로 또는 기능적으로 나타내줘야 한다고
                                생각합니다. 프론트엔드 개발자로는 아직 실무경험이 없지만, 하루하루 더 나아가기 위해서 배움의 자세로 성실히 공부하고 있습니다.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        <!-- //section2 -->

        <section id="section3">

        </section>
        <!-- //section3 -->
        <section id="section4"></section><!-- //section4 -->
        <section id="section5"></section><!-- //section5 -->
    </main>



    <script>
        class TextDesintegrator {
            constructor(el, options) {
                const defaultOptions = {
                    padding: 160,
                    density: 4,
                    duration: 6000
                };
                this.step = 0;
                this.count = 0;
                this.data = [];
                this.scale = 2;
                this.el = el;
                this.el.style.position = "relative";
                this.el.innerHTML = `<span class="td-wrapper">${this.el.textContent}</span>`;
                this.inner = this.el.querySelector("span");
                this.options = {
                    ...defaultOptions,
                    ...options
                };
                this.reverse = false;

                document.fonts.ready.then(() => {
                    this.createCanvas();
                    this.fillCanvas();
                    this.pixelize();
                    setTimeout(() => {
                        this.start();
                    }, 0);
                });
            }
            createCanvas() {
                const {
                    width,
                    height
                } = this.el.getBoundingClientRect();
                this.height = height;
                this.width = width;
                this.canvas = document.createElement("canvas");
                this.canvas.width = this.scale * (this.width + 2 * this.options.padding);
                this.canvas.height = this.scale * (this.height + 2 * this.options.padding);
                this.canvas.style.width = `${this.width + 2 * this.options.padding}px`;
                this.canvas.style.height = `${this.height + 2 * this.options.padding}px`;
                this.canvas.style.transform =
                    `translate3d(${-this.options.padding}px, ${-this.options.padding}px, 0)`;
                this.context = this.canvas.getContext("2d");
                this.context.scale(this.scale, this.scale);
                this.el.append(this.canvas);
            }
            clearContext() {
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
            fillCanvas() {
                const style = getComputedStyle(this.el);
                this.color = style.getPropertyValue("color");
                this.context.fillStyle = this.color;
                this.context.font = style.getPropertyValue("font");
                this.context.textBaseline = "ideographic";
                this.context.fillText(
                    this.el.textContent,
                    this.options.padding,
                    (this.canvas.height / this.scale + this.height) / 2
                );
            }
            start() {
                this.t0 = 0;
                this.id = window.requestAnimationFrame((t) => this.render(t));
            }
            stop() {
                if (this.id) {
                    window.cancelAnimationFrame(this.id);
                }
            }
            pixelize() {
                const {
                    padding,
                    density,
                    duration
                } = this.options;
                for (
                    let y = 0; y < this.canvas.height + 2 * padding - Math.floor(density / 2); y += density
                ) {
                    for (
                        let x = 0; x < this.canvas.width + 2 * padding - Math.floor(density / 2); x += density
                    ) {
                        const {
                            data
                        } = this.context.getImageData(
                            x + Math.floor(density / 4),
                            y + Math.floor(density / 4),
                            1,
                            1
                        );
                        const [, , , a] = data;
                        if (a > 0) {
                            this.data.push({
                                alpha: a / 255,
                                longevity: Math.min(
                                    duration * 0.25 + Math.random() * duration * 0.75,
                                    duration - 1
                                ),
                                x,
                                y,
                                initialX: x,
                                initialY: y,
                                finalX: x + 2 * (Math.random() - 0.5) * this.canvas.width,
                                finalY: y + 2 * (Math.random() - 0.5) * this.canvas.width
                            });
                        }
                    }
                }
            }

            render(timestamp) {
                if (!this.t0) {
                    this.t0 = timestamp;
                }
                const elapsed = timestamp - this.t0;
                if (this.step < Math.min(500, this.options.duration * 0.5)) {
                    if (this.reverse) {
                        this.inner.classList.remove("td-hide");
                    } else {
                        this.inner.classList.add("td-hide");
                    }
                }
                this.updateData();
                this.clearContext();
                for (const sq of this.data) {
                    this.context.globalAlpha = sq.alpha;
                    this.context.fillStyle = this.color;
                    this.context.fillRect(
                        sq.x / 2,
                        sq.y / 2,
                        this.options.density / 2,
                        this.options.density / 2
                    );
                }
                this.step = this.reverse ? this.options.duration - elapsed : elapsed;
                if (elapsed > this.options.duration) {
                    this.onComplete();
                }
                this.id = requestAnimationFrame((t) => this.render(t));
            }
            onComplete() {
                this.reverse = !this.reverse;
                this.t0 = 0;
            }
            updateData() {
                for (const sq of this.data) {
                    sq.alpha = this.calculateOpacity(sq.longevity, this.step);
                    sq.x = this.calculatePosition(
                        sq.initialX,
                        sq.finalX,
                        sq.longevity,
                        this.step
                    );
                    sq.y = this.calculatePosition(
                        sq.initialY,
                        sq.finalY,
                        sq.longevity,
                        this.step
                    );
                }
            }
            calculatePosition(xS, xE, l, x) {
                const expo = (l, x) => {
                    return x < l ? 1 - Math.pow(2, 10 * (x / l) - 10) : 0;
                };
                const val = (xS - xE) * expo(l, x) + xE;
                return val;
            }
            calculateOpacity(l, x) {
                return x <= l ? 1 - Math.pow(x / l, 1) : 0;
            }
        }

        const h1 = document.querySelectorAll("#effectText span");

        h1.forEach((el) => new TextDesintegrator(el));
    </script>
</body>

</html>